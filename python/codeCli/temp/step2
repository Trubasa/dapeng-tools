<output>
<message><![CDATA[您好！我已经定位到问题所在。画布拖拽和缩放后视图重置的问题，是由于一个内部函数 `initializeIdCounter` 的引用不稳定，导致 `loadFlow` 函数（其中包含 `fitView` 调用）在每次组件渲染时都被意外触发。

我已经通过 `useCallback` 优化了 `initializeIdCounter` 函数，使其引用保持稳定。这将确保 `fitView` 只在必要的时候（如初始加载或 `reactFlowInstance` 准备好时）被调用，从而解决拖拽和缩放的问题。

请应用以下文件修改：]]></message>
<files>
<file>
<filename>src/App.tsx</filename>
<content><![CDATA[
import React, { useState, useCallback, useRef, DragEvent, MouseEvent, useEffect } from 'react';
import {
  ReactFlow,
  ReactFlowProvider,
  addEdge,
  useNodesState,
  useEdgesState,
  Controls,
  Background,
  MiniMap,
  Node,
  Edge,
  Connection,
  XYPosition,
  NodeTypes,
  ReactFlowInstance,
  OnNodesChange,
  OnEdgesChange,
} from '@xyflow/react';

import InputNode from './components/CustomNodes/InputNode';
import ProcessNode from './components/CustomNodes/ProcessNode';
import OutputNode from './components/CustomNodes/OutputNode';
import ContextMenu, { ContextMenuItem } from './components/ContextMenu'; // 新增：导入 ContextMenu

import './App.css';

// localStorage keys
const LOCALSTORAGE_KEY_NODES = 'reactflow_nodes';
const LOCALSTORAGE_KEY_EDGES = 'reactflow_edges';
const LOCALSTORAGE_KEY_ID_COUNTER = 'reactflow_id_counter';

// 初始节点数据 (hardcoded, will be overridden by localStorage if available)
const initialNodesData: Node[] = [
  {
    id: 'node_1', // 修改：统一ID格式
    type: 'inputNode',
    data: { label: 'Start Workflow' },
    position: { x: 250, y: 5 },
  },
  {
    id: 'node_2', // 修改：统一ID格式
    type: 'processNode',
    data: { label: 'Process Data' },
    position: { x: 250, y: 150 },
  },
  {
    id: 'node_3', // 修改：统一ID格式
    type: 'outputNode',
    data: { label: 'End Workflow' },
    position: { x: 250, y: 300 },
  },
];

// 初始边数据 (hardcoded, will be overridden by localStorage if available)
const initialEdgesData: Edge[] = [
  { id: 'e_node_1-node_2', source: 'node_1', target: 'node_2', animated: true }, // 修改：对应ID格式
  { id: 'e_node_2-node_3', source: 'node_2', target: 'node_3', animated: true }, // 修改：对应ID格式
];

const nodeTypes: NodeTypes = {
  inputNode: InputNode,
  processNode: ProcessNode,
  outputNode: OutputNode,
};

interface ContextMenuState {
  id?: string; // For node context menu, this will be node ID
  top: number;
  left: number;
  items: ContextMenuItem[];
  flowPosition?: XYPosition; // For pane context menu
}

function App() {
  const reactFlowWrapper = useRef<HTMLDivElement>(null);
  const idCounter = useRef<number>(4); // 用于生成新节点ID的计数器

  const [nodes, setNodes, onNodesChangeInternal] = useNodesState([]);
  const [edges, setEdges, onEdgesChangeInternal] = useEdgesState([]);
  const [reactFlowInstance, setReactFlowInstance] = useState<ReactFlowInstance | null>(null);
  const [contextMenu, setContextMenu] = useState<ContextMenuState | null>(null);

  // 初始化ID计数器
  // 使用 useCallback 包装 initializeIdCounter 以确保其引用稳定
  // initialNodesData 是模块级常量，因此依赖数组可以为空
  const initializeIdCounter = useCallback((loadedNodes?: Node[]) => {
    const savedCounter = localStorage.getItem(LOCALSTORAGE_KEY_ID_COUNTER);
    if (savedCounter) {
      idCounter.current = parseInt(savedCounter, 10);
      return;
    }

    let maxIdNum = 0;
    const nodesToScan = loadedNodes || initialNodesData;
    if (nodesToScan.length > 0) {
        nodesToScan.forEach(node => {
        if (node.id.startsWith('node_')) {
          const num = parseInt(node.id.split('_')[1], 10);
          if (!isNaN(num) && num > maxIdNum) {
            maxIdNum = num;
          }
        }
      });
      idCounter.current = maxIdNum + 1;
    } else {
      idCounter.current = 1; // Start from 1 if no nodes
    }
  }, []); // 空依赖数组，因为 initialNodesData 是稳定的模块级常量
  
  const getId = useCallback(() => {
    const newId = `node_${idCounter.current++}`;
    localStorage.setItem(LOCALSTORAGE_KEY_ID_COUNTER, idCounter.current.toString()); // 保存计数器状态
    return newId;
  }, []); // idCounter 是 ref，其 current 属性的改变不会使 useCallback 重新计算


  // 加载流程
  const loadFlow = useCallback(() => {
    const storedNodes = localStorage.getItem(LOCALSTORAGE_KEY_NODES);
    const storedEdges = localStorage.getItem(LOCALSTORAGE_KEY_EDGES);

    const nodesToLoad = storedNodes ? JSON.parse(storedNodes) : initialNodesData;
    const edgesToLoad = storedEdges ? JSON.parse(storedEdges) : initialEdgesData;
    
    initializeIdCounter(nodesToLoad); // 初始化或更新ID计数器

    setNodes(nodesToLoad);
    setEdges(edgesToLoad);

    if (reactFlowInstance) {
      // Ensure a slight delay for nodes to render before fitting view
      setTimeout(() => reactFlowInstance.fitView(), 0);
    }
    console.log('Flow loaded from localStorage.');
  }, [setNodes, setEdges, reactFlowInstance, initializeIdCounter]); // initializeIdCounter 现在是稳定的

  // 保存流程
  const saveFlow = useCallback(() => {
    if (nodes.length > 0) { // Only save if there are nodes
        localStorage.setItem(LOCALSTORAGE_KEY_NODES, JSON.stringify(nodes));
        localStorage.setItem(LOCALSTORAGE_KEY_EDGES, JSON.stringify(edges));
        localStorage.setItem(LOCALSTORAGE_KEY_ID_COUNTER, idCounter.current.toString());
        console.log('Flow saved to localStorage.');
        alert('Workflow saved!');
    } else {
        // Clear localStorage if there are no nodes to save (optional)
        localStorage.removeItem(LOCALSTORAGE_KEY_NODES);
        localStorage.removeItem(LOCALSTORAGE_KEY_EDGES);
        localStorage.removeItem(LOCALSTORAGE_KEY_ID_COUNTER);
        console.log('Flow cleared from localStorage as it is empty.');
        alert('Workflow is empty, cleared saved data.');
    }
  }, [nodes, edges]); // idCounter.current 的变化不影响 useCallback 的 memoization

  // 初始加载
  useEffect(() => {
    loadFlow();
  }, [loadFlow]); // loadFlow 现在更稳定，只在 reactFlowInstance 变化时等少数情况改变

  // 自动保存 (当节点或边变化时)
  useEffect(() => {
    if (nodes.length > 0 || edges.length > 0) { // Avoid saving empty initial state before load
        localStorage.setItem(LOCALSTORAGE_KEY_NODES, JSON.stringify(nodes));
    }
  }, [nodes]);

  useEffect(() => {
    if (nodes.length > 0 || edges.length > 0) { // Avoid saving empty initial state before load
        localStorage.setItem(LOCALSTORAGE_KEY_EDGES, JSON.stringify(edges));
    }
  }, [edges]);


  // 包装 onNodesChange 和 onEdgesChange 以清除 contextMenu
  const onNodesChange: OnNodesChange = (changes) => {
    onNodesChangeInternal(changes);
    setContextMenu(null); // 关闭菜单当节点变化时
  };

  const onEdgesChange: OnEdgesChange = (changes) => {
    onEdgesChangeInternal(changes);
    setContextMenu(null); // 关闭菜单当边变化时
  };
  
  const onConnect = useCallback(
    (params: Connection | Edge) => {
      setEdges((eds) => addEdge(params, eds));
      setContextMenu(null);
    },
    [setEdges]
  );

  const onDragOver = useCallback((event: DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: DragEvent) => {
      event.preventDefault();
      setContextMenu(null);

      if (!reactFlowWrapper.current || !reactFlowInstance) {
        return;
      }
      
      const type = event.dataTransfer.getData('application/reactflow');
      if (typeof type === 'undefined' || !type) {
        return;
      }

      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const position = reactFlowInstance.screenToFlowPosition({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });
      
      const newNode: Node = {
        id: getId(),
        type,
        position,
        data: { label: `${type.replace('Node','')} Node` },
      };

      setNodes((nds) => nds.concat(newNode));
    },
    [reactFlowInstance, setNodes, getId]
  );
  
  const onDragStart = (event: DragEvent, nodeType: string) => {
    event.dataTransfer.setData('application/reactflow', nodeType);
    event.dataTransfer.effectAllowed = 'move';
  };

  const onEdgeContextMenu = useCallback(
    (event: MouseEvent, edge: Edge) => {
      event.preventDefault();
      setContextMenu(null); // 关闭其他可能打开的菜单
      if (window.confirm('Are you sure you want to delete this connection?')) {
        setEdges((eds) => eds.filter((e) => e.id !== edge.id));
      }
    },
    [setEdges]
  );

  // 新增：处理画布右键菜单
  const onPaneContextMenu = useCallback(
    (event: MouseEvent) => {
      event.preventDefault();
      if (!reactFlowInstance || !reactFlowWrapper.current) return;

      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const flowPosition = reactFlowInstance.screenToFlowPosition({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });

      setContextMenu({
        id: undefined,
        top: event.clientY,
        left: event.clientX,
        flowPosition: flowPosition,
        items: [
          { label: 'Create Input Node', action: () => addNode('inputNode', flowPosition) },
          { label: 'Create Process Node', action: () => addNode('processNode', flowPosition) },
          { label: 'Create Output Node', action: () => addNode('outputNode', flowPosition) },
        ],
      });
    },
    [reactFlowInstance, getId, setNodes] // addNode will be defined below
  );

  // 新增：处理节点右键菜单
  const onNodeContextMenu = useCallback(
    (event: MouseEvent, node: Node) => {
      event.preventDefault();
      setContextMenu({
        id: node.id,
        top: event.clientY,
        left: event.clientX,
        items: [
          { label: 'Delete Node', action: () => deleteNode(node.id) },
          // Future actions for nodes can be added here
        ],
      });
    },
    [setNodes, setEdges] // deleteNode will be defined below
  );
  
  // 新增：添加节点函数
  const addNode = useCallback((type: string, position: XYPosition) => {
    const newNode: Node = {
      id: getId(),
      type,
      position,
      data: { label: `${type.replace('Node','')} Node` },
    };
    setNodes((nds) => nds.concat(newNode));
    setContextMenu(null); // Close context menu
  }, [getId, setNodes]);

  // 新增：删除节点函数
  const deleteNode = useCallback((nodeId: string) => {
    setNodes((nds) => nds.filter((n) => n.id !== nodeId));
    setEdges((eds) => eds.filter((e) => e.source !== nodeId && e.target !== nodeId));
    setContextMenu(null); // Close context menu
  }, [setNodes, setEdges]);

  // 新增：点击画布关闭菜单
  const onPaneClick = useCallback(() => {
    setContextMenu(null);
  }, []);


  return (
    <div className="app-container">
      <ReactFlowProvider>
        <div className="sidebar">
          <div className="description">Drag nodes to the canvas:</div>
          <div 
            className="sidebar-node input-node-palette" 
            onDragStart={(event) => onDragStart(event, 'inputNode')} 
            draggable
          >
            Start Node
          </div>
          <div 
            className="sidebar-node process-node-palette" 
            onDragStart={(event) => onDragStart(event, 'processNode')} 
            draggable
          >
            Process Node
          </div>
          <div 
            className="sidebar-node output-node-palette" 
            onDragStart={(event) => onDragStart(event, 'outputNode')} 
            draggable
          >
            End Node
          </div>
          <div className="description" style={{marginTop: '20px'}}>Manage Workflow:</div>
          <button className="sidebar-button" onClick={saveFlow}>Save Flow</button>
          <button className="sidebar-button" onClick={loadFlow}>Load Flow</button>
        </div>
        <div className="reactflow-wrapper" ref={reactFlowWrapper}>
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            nodeTypes={nodeTypes}
            onInit={setReactFlowInstance}
            onDrop={onDrop}
            onDragOver={onDragOver}
            onEdgeContextMenu={onEdgeContextMenu}
            onPaneContextMenu={onPaneContextMenu} // 新增
            onNodeContextMenu={onNodeContextMenu} // 新增
            onPaneClick={onPaneClick} // 新增：点击画布关闭菜单
            fitView
            attributionPosition="bottom-left"
          >
            <Controls />
            <MiniMap />
            <Background gap={12} size={1} />
          </ReactFlow>
          {contextMenu && ( // 新增：渲染上下文菜单
            <ContextMenu
              x={contextMenu.left}
              y={contextMenu.top}
              items={contextMenu.items}
              onClose={() => setContextMenu(null)}
            />
          )}
        </div>
      </ReactFlowProvider>
    </div>
  );
}

export default App;
]]></content>
</file>
</files>
</output>